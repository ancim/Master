% Format teze zasnovan je na paketu memoir
% http://tug.ctan.org/macros/latex/contrib/memoir/memman.pdf ili
% http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf
% 
% Prilikom zadavanja klase memoir, navedenim opcijama se podešava 
% veličina slova (12pt) i jednostrano štampanje (oneside).
% Ove parametre možete menjati samo ako pravite nezvanične verzije
% mastera za privatnu upotrebu (na primer, u b5 varijanti ima smisla 
% smanjiti 
\documentclass[12pt,oneside]{memoir}

% Paket koji definiše sve specifičnosti mastera Matematičkog fakulteta
\usepackage{matfmaster}
\usepackage{hyperref}
\hypersetup{colorlinks,linkcolor={blue},citecolor={blue},urlcolor={blue}}

%\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{listings}

\lstset{
language=Scala,
basicstyle=\small\ttfamily,
columns=fullflexible,
keywords=[2]{fail},
keywords=[3]{pass},
keywordstyle={\color{blue!80!black}},
keywordstyle=[2]{\color{red!80!black}},
keywordstyle=[3]{\color{green!50!black}},
showstringspaces=false
}
%
% Podrazumevano pismo je ćirilica.
%   Ako koristite pdflatex, a ne xetex, sav latinički tekst na srpskom jeziku
%   treba biti okružen sa \lat{...} ili \begin{latinica}...\end{latinica}.
%
% Opicija [latinica]:
%   ako želite da pišete latiniciom, dodajte opciju "latinica" tj.
%   prethodni paket uključite pomoću: \usepackage[latinica]{matfmaster}.
%   Ako koristite pdflatex, a ne xetex, sav ćirilički tekst treba biti
%   okružen sa \cir{...} ili \begin{cirilica}...\end{cirilica}.
%
% Opcija [biblatex]:
%   ako želite da koristite reference na više jezika i umesto paketa
%   bibtex da koristite BibLaTeX/Biber, dodajte opciju "biblatex" tj.
%   prethodni paket uključite pomoću: \usepackage[biblatex]{matfmaster}
%
% Opcija [b5paper]:
%   ako želite da napravite verziju teze u manjem (b5) formatu, navedite
%   opciju "b5paper", tj. prethodni paket uključite pomoću: 
%   \usepackage[b5paper]{matfmaster}. Tada ima smisla razmisliti o promeni
%   veličine slova (izmenom opcije 12pt na 11pt u \documentclass{memoir}).
%
% Naravno, opcije je moguće kombinovati.
% Npr. \usepackage[b5paper,biblatex]{matfmaster}

% Pomoćni paket koji generiše nasumičan tekst u kojem se javljaju sva slova
% azbuke (nema potrebe koristiti ovo u pravim disertacijama)
%\usepackage{pangrami}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsthm}

% Datoteka sa literaturom u BibTex tj. BibLaTeX/Biber formatu
\bib{tezaBib}

% Ime kandidata na srpskom jeziku (u odabranom pismu)
\autor{Aна Д. Митровић}
% Naslov teze na srpskom jeziku (u odabranom pismu)
\naslov{Примена Скале у паралелизацији расплинутог тестирања}
% Godina u kojoj je teza predana komisiji
\godina{2018}
% Ime i afilijacija mentora (u odabranom pismu)
\mentor{др Милена Вујошевић Јаничић, доцент\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija prvog člana komisije (u odabranom pismu)
\komisijaA{др Саша Малков, ванредни професор\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija drugog člana komisije (u odabranom pismu)
\komisijaB{др Александар Картељ, доцент\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija trećeg člana komisije (opciono)
% \komisijaC{}
% Ime i afilijacija četvrtog člana komisije (opciono)
% \komisijaD{}
% Datum odbrane (obrisati ili iskomentarisati narednu liniju ako datum odbrane nije poznat)
\datumodbrane{15. јануар 2016.}

% Apstrakt na srpskom jeziku (u odabranom pismu)
\apstr{%
}

% Ključne reči na srpskom jeziku (u odabranom pismu)
\kljucnereci{}

\begin{document}
% ==============================================================================
% Uvodni deo teze
\frontmatter
% ==============================================================================
% Naslovna strana
\naslovna
% Strana sa podacima o mentoru i članovima komisije
\komisija
% Strana sa podacima o disertaciji na srpskom jeziku
\apstrakt
% Sadržaj teze
\tableofcontents*

% ==============================================================================
% Glavni deo teze
\mainmatter
% ==============================================================================

% ------------------------------------------------------------------------------
\chapter{Увод}
% ------------------------------------------------------------------------------

% ------------------------------------------------------------------------------
\chapter{Програмски језик Скала}
\label{chp:razrada}
% ------------------------------------------------------------------------------

Скала је језик опште намене настао 2003. године са циљем да превазиђе ограничења програмског језика Јава комбиновањем објектно оријентисанe и функционалнe програмске парадигме. Мотивација иза овакве идеје је не ограничавати се на једну од ових парадигми и њених предности већ искористити најбоље из оба света. Управо због овакве комбинације парадигми Скала је веома погодна за решавање различитих врста проблема, почевши од малих незахтевних скриптова па све до великих компликованих система. На основу ове прилагодљивости је и добила своје име: реч "скала" означава "скалабилан језик" (енг. \textit{scalable language}), односно језик који ће се прилагођавати и расти заједно са потребама система. \cite{progInScala, ScalaWiki}
\par Творац Скале је Мартин Одерски (нем. \textit{Martin Odersky}) (1958-), немачки научник и професор на универзитету EPFL (École Polytechnique Fédérale de Lausanne) у Лозани, Швајцарској. Још док је био студент, имао је жељу да укомбинује објектну и функционалну парадигму, говорећи да су ове две парадигме само две стране истог новчића. Желео је да напише језик који се преводи у Јава бајт код али и да превазиђе ограничења језика Јава. Први резултат оваквог његовог рада је био језик Funnel, који због свог минималистичког дизајна није заживео. Тако је настала Скала, на којој је Мартин радио од 2001. године заједно са својом групом на универзитету EPFL. Познат је и по другим радовима, као што je имплементација GJ (Generic Java) компајлера који је постао основа javac компајлера. \cite{MartinEpfl, ScalaHistory}

\section{Опште карактеристике}

\textbf{Компатибилност са Јавом} Скала није сама по себи продужење Јаве али је потпуно компатибилна са њом: њен изворни код се преводи у Јава бајт код који се извршава на Јава виртуелној машини. Из кода писаног у Скали је омогућено коришћење Јава библиотека, класа, интерфејса, метода, поља и типова без посебне синтаксе. Омогућено је и обрнуто, позивање Скала кода из Јаве, мада се оно ређе користи. Такође, Скала омогућава лакшу и лепшу употребу Јава типова уз помоћ имплицитне конверзије омогућавајући употребу својих метода за манипулацију типовима. Компатибилност олакшава развијаоцима софтвера лакши прелазак из Јаве у Скалу јер нису принуђени да се одједном одрекну написаног кода у Јави. \cite{progInScala}

\textbf{Објектно оријентисана парадигма} Писање програма и смештање података и њихових својстава у класе и објекте тих класа је веома популарно и интуитивно развијаоцима софтвера. Скала је то задржала притом мало изменивши концепт. У многим језицима укључујући и Јаву су дозвољене вредности  које нису објекти или нису у склопу истог. То могу бити примитивне вредности у Јави или статичка поља и методи који не припадају ниједном објекту.  Скала то не дозвољава и зато је објектно оријентисан језик у \textit{чистој форми}: "Свака вредност је објекат и свака операција је позив метода" \cite{progInScala}. Елегантан начин коришћења метода налик на операције је један од начина на који се Скала брине да програмерима буде пријатно њено коришћење.

\textbf{Концизност} Скала код има тенденцију да буде краћи од Јава кода, чак се процењује да има барем два пута мање линија кода од Јаве. Постоје и екстремни случајеви где је број линија и десет пута мањи. Ова особина није значајна само због тога што знатно олакшава програмеру у писању кода, већ олакшава читање кода и откривање грешака којих ионако има мање јер има мање простора за њих. Ово је нешто што одликује саму синтаксу језика, а веома помажу и разне библиотеке које имају већ имплементиране многе функције које врше послове са којима се често сусрећемо. Лако се и имплементирају и касније употребљавају библиотеке које сами напишемо. Такође, Скала подржава аутоматско закључивање типова (енг. \textit{type inference}) што омогућава изостављање понављања већ наведених типова, што резултује читљивијим кодом. \cite{progInScala}

\textbf{Висок ниво} Како је Скала погодна и за велике и комплексне системе она се труди да се прилагоди њиховим захтевима подижући ниво апстракције у свом коду. Омогућава много једноставнији и краћи начин кодирања разних проблема. Рецимо, уместо да пролазимо кроз ниску карактера карактер по карактер користећи петљу, у Скали се то може урадити у једној линији кода помоћу \textit{предиката} тј.  \textit{функцијских литерала} који су детаљније објашњени у поглављу \ref{sec:funkDeoJezika}. Скала код тежи да буде разумљивији и мање комплексан како би олакшао већ комплексан систем који се имплеметира. \cite{progInScala}

\textbf{Статичка типизираност} Скала је статички типизиран језик што значи да се типови података који су коришћени знају у време компилације. Неки сматрају ово маном као и да је навођење типова сувишно поред техника тестирања софтвера као што је нпр. тестирање јединица кода (енг. \textit{unit testing}). Ипак, у Скали је статичка типизираност напреднија јер нам дозвољава да изоставимо тип на местима где би он био поновљен и вероватно би нам само сметао. Због оваквих понављања која су неопходна у неким језицима, многи се одрекну предности статички типизираних језика као што су: детектовање разних грешака у време компилације, лакше рефакторисање кода и коришћење типова као вид документације.
\cite{progInScala}

\textbf{Корен језика} Корен Скале није само језик Јава, иако је Јава имала највећи утицај у њеном стварању. Идеје и концепти из разних језика, како објектно оријентисаних тако и функционално оријентисаних, су инспирисали развој Скале. Међу њима су језици: C\#  од кога је Скала преузела синтаксне конвенције, Erlang чије идеје су сличне идејама конкурентности базиране на моделу Actors и други: C, C++,  Smalltalk, Ruby, Haskell, SML, F\# итд. \cite{progInScala}
\\
\par Карактеристика која највише раздваја Скалу од Јаве је њена \textbf{функционалност} - Скала је у потпуности функционалан језик. Ова особина је детаљно објашњена у следећем поглављу.


% --------
\section{Функционални део језика}
\label{sec:funkDeoJezika}

Функцинална парадигма се развија од 1960-тих година. У њеној основи леже \textit{ламбда рачун} (енг. \textit{$\lambda$-calculus}) и комбинаторна логика. Ламбда рачун представља математичку апстракцију и формализам за описивање функција и њихово израчунавање. Њега је увео Алонзо Черч (енг. \textit{Alonzo Church}) 1930-тих година а Алан Тјуринг (енг. \textit{Alan Turing}) је 1937. године показао да је експресивност ламбда рачуна еквивалентна експресивности Тјурингових машина. Иако је ламбда рачун првобитно развијен само за потребе математике, данас се он сматра првим функционалним језиком. Други модел рачунања који је утицао на функционалне програмске језике, комбинаторну логику, створили су Мојсеј Шејнфинкел (рус. \textit{Моисей Шейнфинкель}) и Хаскел Кари (енг. \textit{Haskell Curry}) 1924. године са циљем да елиминишу употребу променљивих у математичкој логици. \cite{funkWiki, funkMilena, lambdaWiki, kombWiki}
\par Најстарији виши функционални програмски језик је LISP који је пројектовао Џон Макарти (енг. \textit{John McCarthy}) на институту МИТ (Масачусетски технолошки институт) 1958. године. Након тога се полако развијају и други функционални језици као што су ISWIM, FP, Scheme, ML, Miranda, Erlang, SML, Haskell, OCAML,  F\#, Elixir итд. Поред функционалних језика постоје и језици који нису функционални али  у одређеној мери подржавају функционалне концепте или могу да их остваре на други начин, нпр. Java, C, C$++$, C\#, Phyton. \cite{funkMilena, lispWiki}
\par Разлика између императивне и функционалне парадигме се може описати дефинисањем самог програма\cite{funkMalkov}:
\begin{itemize}
\item Императивна парадигма: 
\\Програм представља формално упутство о томе шта рачунар треба да ради да би урадио неки посао
\\Програм представља одговор на питање КАКО се нешто РАДИ
\item Функционална парадигма:
\\Програм представља формално објашњење онога што рачунар треба да израчуна
\\Програм представља одговор на питање ШТА се РАЧУНА
\end{itemize}
\par Функционални језици су веома блиски математици због чега се и називају \textit{функционалним} језицима: њихове функције се понашају као функције у математичком смислу. О томе говоре следећа два концепта којима се воде функционални језици\cite{progInScala}: 
\\
\par Први концепт се односи на \textbf{"статус" функција}. У функционалним језицима функције су вредности \textit{првог реда}, тј. \textit{грађани првог реда}. То значи да се оне могу користити као вредности типова као што су нпр. цели, реални бројеви, ниске карактера итд. Статус оваквих типова се не разликује од статуса функција, што у многим језицима није случај. Ово омогућава коришћење функција на природан, концизан и читљив начин: као аргументе других функција, повратне вредности функција, њихово чување у променљивим, угњеждавање и слично. Другим речима, функције се креирају и прослеђују без икаквих рестрикција на које смо навикли у императивним језицима.
\par У Скали можемо користити локалне (угњеждене) функције које су често веома мале и лако се комбинују како би заједно заокружиле један већи посао. Ово одговара функционалном стилу који промовише следећу идеју: програм треба изделити на много мањих функција (целина) од којих свака има јасно дефинисан задатак.
\par Посебно су корисни и важни \textit{функцијски литерали} који представљају функције које могу бити неименоване (анонимне функције) и прослеђиване као обичне вредности. Назив "функцијски литерал" се користи за функције у изворном коду, а у време извршавања оне се називају \textit{"функцијским вредностима"} (разлика слична разлици између класа и објеката у објектно оријентисаним језицима). Функцијске вредности су објекти које можемо чувати у променљивама али су истовремено и функције које можемо позивати. Пример функцијског литерала који инкрементира цео број изгледа овако \cite{progInScala}:
\begin{lstlisting}[language=Scala]
var increase = (x: Int) => x + 1
increase(10)
\end{lstlisting}
Променљива \textbf{increase} је објекат који садржи литерал, али је и функција коју позивамо са аргументом 10.
\\
\par Други концепт се односи на \textbf{непостојање стања} које се иначе представља променљивама у програму. То значи да извршавање метода нема\textit{ "бочне ефекте"}, односно да функције које позивамо не мењају податке "у месту" већ враћају нове вредности као резултате свог израчунавања. Избегава се (у чисто функционалним језицима се избацује) кад год је то могуће коришћење променљивих које мењају своје стање, а за промену се користе променљиве код којих то није дозвољено. То су променљиве које се иницијализују само једном. Оне се у Скали дефинишу помоћу кључне речи \textbf{val} и покушај промене вредности ове променљиве након што је иницијализована резултирао би грешком. Променљиве које су стандардне у императивним језицима и које можемо мењати по потреби се дефинишу кључном речју \textbf{var}.
\par Овакво непостојање стања има за последицу избацивање итеративних конструкција. Овакав резон може испрва деловати чудно, међутим све што се може остварити кроз итерације се може остварити и \textit{рекурзијом} јер је експресивност функционалних језика еквивалентна експресивности императивних језика. Рекурзија је у функционалним језицима потпуно природна, много примењенија и неизбежна. Некада се решења проблема који захтевају стање у оваквим језицима превише закомпликују, али оно се може направити по потреби на друге начине тако да се ово не сматра недостатком. Предност је у томе што не морамо пратити вредности променљивих и њихове промене што олакшава разумевање програма. Један програм у функционалном језику представља низ дефиниција и позива функција а његово извршавање је евалуација тих функција.\cite{funkMilena}
\par Као пример метода који нема бочне ефекте може послужити метод \textbf{replace} који као аргументе добија ниску карактера и два карактера. Његов задатак је да у датој ниски замени сва појављивања једног карактера другим карактером. Он неће променити ниску коју је добио као аргумент, већ ће вратити нову која више нема појављивања датог карактера који смо заменили новим.  
\par Ова особина метода без бочних ефеката назива се \textit{референтна прозирност}: "за било које вредности аргумената позив метода се може заменити својим резултатом без промене семантике програма"\cite{progInScala}. Пример:

\begin{lstlisting}[language=Scala]
val p = previous(90)
\end{lstlisting}
Свако појављивање променљиве p можемо заменити са изразом previous(90).

За овакве методе кажемо да су референтно прозирни или транспарентни (енг. \textit{referentially transparent}) и они су концизнији, читљивији и производе мање грешака јер немају пропратне ефекте. Ипак, у пракси су нам углавном неопходни пропратни ефекти због чега они могу бити присутни на контролисан начин. У том случају, програмски језик више није чисто функционалан. Још једна особина која одликује језике са референтном прозирношћу је да редослед операција тј. наредби није важан. У императивним језицима ситуација се веома разликује.\cite{funkMilena}
\\
\par Чисто функционални језици (нпр. Haskel, Miranda) захтевају коришћење имутабилних структура података,  референтно прозирних метода и рекурзије. Други језици, као што су Скала, Python, Ruby итд. охрабрују овакво програмирање али не условљавају програмера. Скала омогућава бирање начина за решавање проблема и нуди функционалне алтернативе за све императивне конструкције. На овај начин програмер се полако и без притиска навикава на другачији начин размишљања.\cite{funkMilena, progInScala}
\par Неке од карактеристика које Скала подржава а које су заједничке и другим функционалним језицима су\cite{progInScala}:
\begin{itemize}
	\item \textbf{Функције вишег реда} %strana 210
Функције вишег реда су оне које имају друге функције као своје аргументе. Оне поједностављују код и смањују његово понављање. Ово је пример функције која као аргументе има ниску карактера \textbf{query} и другу функцију \textbf{matcher}:
\begin{lstlisting}[language=Scala]
def filesMatching(query: String, 
		matcher: (String, String) => Boolean) = {
	for (file <- filesHere; if matcher(file.getName, query))
		yield file
}
\end{lstlisting}
Функција \textbf{filesMatching} треба да међу фајловима \textbf{filesHere} пронађе фајлове који испуњавају неки критеријум. Да се код не би понављао за сваки критеријум појединачно, он се прослеђује функцији као аргумент у виду функције \textbf{matcher}. Сам критеријум представља функцију која има две ниске карактера као аргумент, и враћа логички тип - тачно ако је критеријум испуњен и нетачно у супротном.
\par Следећи пример демонстрира коришћење функције вишег реда из Скала библиотеке:
\begin{lstlisting}[language=Scala]
def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)
\end{lstlisting}
Метод \textbf{exists} проверава постојање елемента листе \textbf{nums} који задовољава наведени предикат који му је прослеђен као аргумент (дељивост са 2).  Постоји доста метода сличних методу exists, попут: \textbf{find}, \textbf{filter}, \textbf{foreach}, \textbf{forall}, итд.

\item \textbf{Каријеве функције} %strana 214
Каријеве функције уместо једне листе аргумената узимају аргументе један по један, имајући више листи које садрже по један аргумент. На овај начин омогућују дефинисање функција помоћу већ дефинисаних на следећи начин:
\begin{lstlisting}[language=Scala]
def curriedSum(x: Int)(y: Int) = x + y
\end{lstlisting}
Ово је функција која сабира два цела броја. Када је позовемо на овај начин:
\begin{lstlisting}[language=Scala]
curriedSum(1)(2)
\end{lstlisting}
десиће се два позива функције. Први позив ће узети први параметар \textbf{x} и вратити другу функцију која узима параметар \textbf{y}, и враћа збир ова два параметра. Прва и друга функција би редом изгледале овако:
\begin{lstlisting}[language=Scala]
def first(x: Int) = (y: Int) => x + y
val second = first(1) /* poziv prve funkcije */
second(2) /* poziv druge funkcije */
\end{lstlisting}
Каријев поступак има пуно примена. Рецимо, можемо дефинисати функцију која додаје број 1 неком целом броју:
\begin{lstlisting}[language=Scala]
val onePlus = curriedSum(1)_
onePlus(2) /* --> vraca 3 */
\end{lstlisting}
Позивамо Каријеву функцију \textbf{curriedSum} користећи \textbf{$\_$} као знак да на том месту може бити било која вредност (енг. \textit{wildcard}). Суштина је да је функција \textbf{onePlus} дефинисана помоћу Каријеве функције која сабира било која два цела броја, а код које је први аргумент везан за број 1.
\item \textbf{Упаривање образаца}
Честo је потребно препознати да ли неки израз има одређену форму тј. да ли одговара одређеном обрасцу. То је корисно уколико треба да се имплементира функција која ради различите ствари у зависности од типова аргумената. Уобичајени примери су аритметичке операције или секвенце одређеног типа. Ово је пример са листама: 
\begin{lstlisting}[language=Scala]
expr match {
	case List(0, _, _) => println("found it")
	case _ =>
}
\end{lstlisting}
Помоћу кључне речи \textbf{match} проверавамо да ли израз \textbf{expr} одговара некој листи од три елемента којој је први елемент 0 а друга два било који бројеви. Пошто се израз \textbf{expr} пореди редом са случајевима како су наведени, након неуспешног поређења са трочланом листом успешно ће се упарити са \textbf{$\_$} који служи као образац који одговара свему (енг. \textit{wildcard pattern}). 

\item \textbf{Comprehensions}
Конструкција \textbf{for expression} или \textbf{for comprehension} се често користи у Скали не само за стандардно итерирање кроз колекције већ и на другачије начине, на пример:
\begin{lstlisting}[language=Scala]
val forLineLengths =
	for {
		file <- filesHere 	/* iteriranje kroz listu fajlova */
		if file.getName.endsWith(".scala") 	/* prvi uslov */
		line <- fileLines(file) 	/* iteriranje kroz linije fajla */
		trimmed = line.trim 	/* dodela promenljivoj trimmed */
		if trimmed.matches(".*for.*") 	/* drugi uslov */
	} yield trimmed.length 		/* povratna vrednost */
\end{lstlisting}
Овај пример обухвата пуно могућности које пружају \textbf{for} изрази. Прво, итерирање кроз листу \textbf{filesHere} користећи \textbf{<-} метод. Друго, филтрирање тих фајлова помоћу услова задатог у \textbf{if} изразy. Онда следи једна угњеждена петља где се врши итерација кроз линије тренутног фајла (који је испунио услов, а ако није, прелази се на следећи фајл). Након тога, чување тренутне тримоване линије у променљивој \textbf{trimmed} и још један \textbf{if} израз. Најзад, помоћу \textbf{yield} наредбе враћа се дужина тримоване линије чиме се попуњава листа \textbf{forLineLengths}. Дакле, можемо користити угњеждене петље, филтрирати резултате, чувати податке у променљивама и попуњавати колекције помоћу \textbf{yield} наредбе. Све ове опције нам омогућавају конструкције које подсећају на дефинисање елемената скупова у математици.
\end{itemize}

\par Ово су неке од најважнијих функционалних особина Скале. Управо њена функционална својства су кључни разлози због којих је Скала веома погодна за паралелизацију израчунавања. 
%--------

% --------
\section{Паралелизам}

%--------

% ------------------------------------------------------------------------------
\chapter{Закључак}
% ------------------------------------------------------------------------------

% ------------------------------------------------------------------------------
% Literatura
% ------------------------------------------------------------------------------
\literatura

% ==============================================================================
% Završni deo teze i prilozi
\backmatter
% ==============================================================================

% ------------------------------------------------------------------------------
% Biografija kandidata
\begin{biografija}
\textbf{Вук Стефановић Караџић} (\emph{Тршић, 26. октобар/6. новембар
  1787. — Беч, 7. фебруар 1864.}) био је српски филолог, реформатор
српског језика, сакупљач народних умотворина и писац првог речника
српског језика.  Вук је најзначајнија личност српске књижевности прве
половине XIX века. Стекао је и неколико почасних доктората.
Учествовао је у Првом српском устанку као писар и чиновник у
Неготинској крајини, а након слома устанка преселио се у Беч,
1813. године. Ту је упознао Јернеја Копитара, цензора словенских
књига, на чији је подстицај кренуо у прикупљање српских народних
песама, реформу ћирилице и борбу за увођење народног језика у српску
књижевност. Вуковим реформама у српски језик је уведен фонетски
правопис, а српски језик је потиснуо славеносрпски језик који је у то
време био језик образованих људи. Тако се као најважније године Вукове
реформе истичу 1818., 1836., 1839., 1847. и 1852.
\end{biografija}
% ------------------------------------------------------------------------------

\end{document} 